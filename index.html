<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <title>Grid environment enhanced</title>
    <style>
      :root {
        --cell-size: 72px;
        --font-family: "Segoe UI", Roboto, Arial, sans-serif;
      }
      body {
        font-family: var(--font-family);
        display: flex;
        gap: 24px;
        justify-content: center;
        padding: 24px;
        background: #f5f7fb;
      }
      .grid-wrap {
        background: #fff;
        padding: 16px;
        border-radius: 12px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.08);
      }
      .legend {
        max-width: 240px;
        background: #fff;
        padding: 14px;
        border-radius: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
        font-size: 14px;
      }
      svg {
        display: block;
      }
      .legend-row {
        display: flex;
        gap: 10px;
        margin: 8px 0;
        align-items: center;
      }
      .swatch {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 1px solid #ddd;
      }
      .agent-swatch {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: steelblue;
        border: 2px solid #fff;
      }
      .intr-swatch {
        width: 18px;
        height: 18px;
        background: #e33;
        transform: rotate(45deg);
      }
      .controls button {
        padding: 8px 10px;
        border-radius: 8px;
        border: 0;
        cursor: pointer;
        background: #2b6df6;
        color: #fff;
        margin-top: 6px;
      }
      text {
        font-family: var(--font-family);
      }
      .cell-label {
        font-size: 11px;
        fill: #0b1220;
        font-weight: 600;
      }
      .cell-sub {
        font-size: 10px;
        fill: #0b1220;
        opacity: 0.9;
      }
    </style>
  </head>

  <body>
    <div class="grid-wrap" id="gridWrap"></div>

    <div class="legend">
      <h3>Легенда</h3>
      <div class="legend-row">
        <div
          class="swatch"
          style="background: linear-gradient(#eafaf0, #a8f0b8)"
        ></div>
        Ценность (c)
      </div>
      <div class="legend-row">
        <div class="agent-swatch"></div>
        Агент
      </div>
      <div class="legend-row">
        <div class="intr-swatch"></div>
        Нарушители
      </div>
      <div class="controls">
        <button id="randomBtn">Рандомизировать</button>
        <button id="exportBtn">Экспорт PNG</button>
      </div>
    </div>

    <script>
      let N = 8;
      let cellSize = parseInt(
        getComputedStyle(document.documentElement).getPropertyValue(
          "--cell-size"
        )
      );
      let agentPos = { r: 3, c: 2 };
      let intruders = [];
      let muGrid = null;
      let cGrid = null;

      const C_MAX = 1000;

      function generateRoad(mu, c) {
        // стартуем на левой стороне
        let r = Math.floor(Math.random() * N);
        let col = 0;

        mu[r][col] = 0.98;
        c[r][col] = 0;

        // шаги только по 4 направлениям: вверх, вниз, вправо, влево
        // пусть дорога всегда движется ВПРАВО, иногда поднимаясь/опускаясь
        while (col < N - 1) {
          // возможные шаги (только ортогональные, без диагонали)
          let candidates = [];

          // вправо (главное направление)
          candidates.push({ dr: 0, dc: 1 });

          // возможно вверх/вниз для «поворотов дороги»
          if (r > 0) candidates.push({ dr: -1, dc: 0 });
          if (r < N - 1) candidates.push({ dr: 1, dc: 0 });

          // выбираем случайный шаг
          let step = candidates[Math.floor(Math.random() * candidates.length)];
          let nr = r + step.dr;
          let nc = col + step.dc;

          // гарантируем движение вперёд
          if (nc <= col) {
            // запрещаем движение назад или стояние
            nc = col + 1;
            nr = r;
          }

          r = nr;
          col = nc;

          mu[r][col] = 0.98;
          c[r][col] = 0;
        }
      }

      function randGrid() {
        const mu = Array.from({ length: N }, () =>
          Array.from(
            { length: N },
            () => +(Math.random() * 0.9 + 0.05).toFixed(2)
          )
        );
        const c = Array.from({ length: N }, () =>
          Array.from({ length: N }, () => 0)
        );

        // генерация ценностей
        for (let k = 0; k < Math.round(N * 1.4); k++) {
          const pr = Math.floor(Math.random() * N);
          const pc = Math.floor(Math.random() * N);
          const peak = Math.floor(Math.random() * 1500 + 200);
          for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
              const ri = pr + i,
                cj = pc + j;
              if (ri >= 0 && ri < N && cj >= 0 && cj < N) {
                const decay = (Math.abs(i) + Math.abs(j)) * 0.25;
                c[ri][cj] = Math.max(c[ri][cj], Math.floor(peak * (1 - decay)));
              }
            }
          }
        }

        // добавляем дорогу
        generateRoad(mu, c);

        return { mu, c };
      }

      function selectIntruders(mu, c) {
        let border = [];

        // граница
        for (let i = 0; i < N; i++) {
          border.push({ r: 0, c: i });
          border.push({ r: N - 1, c: i });
          border.push({ r: i, c: 0 });
          border.push({ r: i, c: N - 1 });
        }

        // фильтр по максимальной проходимости μ
        let bestMu = 0;
        for (let p of border) {
          if (mu[p.r][p.c] > bestMu && c[p.r][p.c] === 0) {
            bestMu = mu[p.r][p.c];
          }
        }

        let candidates = border.filter(
          (p) => mu[p.r][p.c] === bestMu && c[p.r][p.c] === 0
        );

        // выбираем 2–3 нарушителей
        let k = 2;
        let arr = [];
        for (let i = 0; i < k; i++) {
          if (candidates.length === 0) break;
          let idx = Math.floor(Math.random() * candidates.length);
          arr.push(candidates[idx]);
          candidates.splice(idx, 1);
        }
        return arr;
      }

      function render() {
        const wrap = document.getElementById("gridWrap");
        wrap.innerHTML = "";

        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", N * cellSize);
        svg.setAttribute("height", N * cellSize);

        for (let r = 0; r < N; r++) {
          for (let c = 0; c < N; c++) {
            const x = c * cellSize,
              y = r * cellSize;

            let rect = document.createElementNS(svgNS, "rect");
            rect.setAttribute("x", x);
            rect.setAttribute("y", y);
            rect.setAttribute("width", cellSize);
            rect.setAttribute("height", cellSize);
            rect.setAttribute("fill", "#fff");
            rect.setAttribute("stroke", "#d0d7df");
            svg.appendChild(rect);

            let valC = cGrid[r][c];
            if (valC > 0) {
              let scaled = Math.min(valC, C_MAX) / C_MAX;
              let opacity = 0.18 + 0.72 * scaled;
              let fill = `hsla(120,60%,45%,${opacity.toFixed(3)})`;

              let grect = document.createElementNS(svgNS, "rect");
              grect.setAttribute("x", x);
              grect.setAttribute("y", y);
              grect.setAttribute("width", cellSize);
              grect.setAttribute("height", cellSize);
              grect.setAttribute("fill", fill);
              svg.appendChild(grect);
            }

            let muText = document.createElementNS(svgNS, "text");
            muText.setAttribute("x", x + 6);
            muText.setAttribute("y", y + 14);
            muText.setAttribute("class", "cell-label");
            muText.textContent = `μ=${muGrid[r][c]}`;
            svg.appendChild(muText);

            let cText = document.createElementNS(svgNS, "text");
            cText.setAttribute("x", x + 6);
            cText.setAttribute("y", y + 28);
            cText.setAttribute("class", "cell-sub");
            cText.textContent = `c=${cGrid[r][c]}`;
            svg.appendChild(cText);
          }
        }

        // Agent
        let ax = agentPos.c * cellSize + cellSize / 2;
        let ay = agentPos.r * cellSize + cellSize / 2;
        let agent = document.createElementNS(svgNS, "circle");
        agent.setAttribute("cx", ax);
        agent.setAttribute("cy", ay);
        agent.setAttribute("r", cellSize * 0.18);
        agent.setAttribute("fill", "steelblue");
        agent.setAttribute("stroke", "#fff");
        agent.setAttribute("stroke-width", 2);
        svg.appendChild(agent);

        let aLab = document.createElementNS(svgNS, "text");
        aLab.setAttribute("x", ax);
        aLab.setAttribute("y", ay + 4);
        aLab.setAttribute("text-anchor", "middle");
        aLab.setAttribute("font-size", cellSize * 0.3);
        aLab.setAttribute("fill", "#fff");
        aLab.setAttribute("font-weight", "700");
        aLab.textContent = "A";
        svg.appendChild(aLab);

        // Intruders
        intruders.forEach((pos) => {
          const ix = pos.c * cellSize + cellSize / 2;
          const iy = pos.r * cellSize + cellSize / 2;

          const size = cellSize * 0.28;

          let r1 = document.createElementNS(svgNS, "rect");
          r1.setAttribute("x", ix - size / 2);
          r1.setAttribute("y", iy - size * 0.07);
          r1.setAttribute("width", size);
          r1.setAttribute("height", size * 0.14);
          r1.setAttribute("fill", "#e33");
          r1.setAttribute("transform", `rotate(45 ${ix} ${iy})`);
          svg.appendChild(r1);

          let r2 = document.createElementNS(svgNS, "rect");
          r2.setAttribute("x", ix - size / 2);
          r2.setAttribute("y", iy - size * 0.07);
          r2.setAttribute("width", size);
          r2.setAttribute("height", size * 0.14);
          r2.setAttribute("fill", "#e33");
          r2.setAttribute("transform", `rotate(-45 ${ix} ${iy})`);
          svg.appendChild(r2);
        });

        wrap.appendChild(svg);
      }

      // RANDOMIZE
      document.getElementById("randomBtn").onclick = () => {
        let g = randGrid();
        muGrid = g.mu;
        cGrid = g.c;

        agentPos = {
          r: Math.floor(Math.random() * N),
          c: Math.floor(Math.random() * N),
        };

        intruders = selectIntruders(muGrid, cGrid);
        render();
      };

      // EXPORT PNG
      document.getElementById("exportBtn").onclick = () => {
        const svg = document.querySelector("#gridWrap svg");
        const serializer = new XMLSerializer();
        const svgStr = serializer.serializeToString(svg);
        const blob = new Blob([svgStr], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement("canvas");
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext("2d");
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
          const png = canvas.toDataURL("image/png");
          const a = document.createElement("a");
          a.href = png;
          a.download = "grid.png";
          a.click();
          URL.revokeObjectURL(url);
        };
        img.src = url;
      };

      // Initialize
      let g = randGrid();
      muGrid = g.mu;
      cGrid = g.c;
      intruders = selectIntruders(muGrid, cGrid);
      render();
    </script>
  </body>
</html>
